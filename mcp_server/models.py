# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T09:16:10+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from ipaddress import IPv4Address
from typing import Any, Dict, List, Optional, Union

from pydantic import (
    AnyUrl,
    BaseModel,
    ConfigDict,
    Field,
    RootModel,
    confloat,
    conint,
    constr,
)


class Realm(Enum):
    customer = 'customer'
    contributor = 'contributor'


class AccessTokenDetails(BaseModel):
    client_id: Optional[str] = Field(
        None, description='Client ID that is associated with the user'
    )
    contributor_id: Optional[str] = Field(
        None, description='Contributor ID that is associated with the user'
    )
    customer_id: Optional[str] = Field(
        None, description='Customer ID that is associated with the user'
    )
    expires_in: Optional[int] = Field(
        None,
        description='Number of seconds until the access token expires; no expiration if this value is null',
    )
    organization_id: Optional[str] = Field(
        None, description='Organization ID that is associated with the user'
    )
    realm: Optional[Realm] = Field(None, description='Type of access token')
    scopes: Optional[List[str]] = Field(
        None,
        description='Scopes that this access token provides when used as authentication',
    )
    user_id: Optional[str] = Field(
        None, description='User ID that is associated with the user'
    )
    username: Optional[str] = Field(
        None, description='User name that is associated with the user'
    )


class Album(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The album ID')
    title: str = Field(..., description='The album title')


class Allotment(BaseModel):
    downloads_left: Optional[int] = Field(
        None, description='Number of credits remaining in the subscription'
    )
    downloads_limit: Optional[int] = Field(
        None, description='Total number of credits available to this subscription'
    )
    end_time: Optional[datetime] = Field(None, description='Date the subscription ends')
    start_time: Optional[datetime] = Field(
        None, description='Date the subscription started'
    )


class Artist(BaseModel):
    name: str = Field(..., description="The artist's name")


class AudioAssetDetails(BaseModel):
    file_size: Optional[int] = Field(None, description='File size of the track')
    url: Optional[str] = Field(None, description='URL the track is available at')


class Preset(Enum):
    MASTER_MP3 = 'MASTER_MP3'
    MASTER_WAV = 'MASTER_WAV'
    STEMS_WAV = 'STEMS_WAV'


class Status(Enum):
    WAITING_COMPOSE = 'WAITING_COMPOSE'
    RUNNING_COMPOSE = 'RUNNING_COMPOSE'
    WAITING_RENDER = 'WAITING_RENDER'
    RUNNING_RENDER = 'RUNNING_RENDER'
    CREATED = 'CREATED'
    FAILED_CREATE = 'FAILED_CREATE'


class SpanType(Enum):
    metered = 'metered'
    unmetered = 'unmetered'


class Status1(Enum):
    active = 'active'
    inactive = 'inactive'


class AudioRenderTimelineSpanInstrumentGroupStatus(BaseModel):
    beat: float = Field(
        ..., description='The beat, relative to the span, at which the status begins'
    )
    status: Status1 = Field(..., description='Whether the instrument is playing or not')


class Event(Enum):
    ending = 'ending'
    transition = 'transition'


class Type(Enum):
    ringout = 'ringout'
    cut = 'cut'


class EndType(BaseModel):
    beat: float = Field(
        ...,
        description='The beat, relative to the start of the active region, at which the end_type begins; in other words, the ending starts on this beat of the region',
    )
    event: Event = Field(..., description='The type of event')
    type: Type = Field(
        ...,
        description='The specific action to perform; if the event type is "ending" then this must be "ringout" and if event type is "transition" this must be "cut"',
    )


class TonicAccidental(Enum):
    double_flat = 'double flat'
    flat = 'flat'
    natural = 'natural'
    sharp = 'sharp'
    double_sharp = 'double sharp'


class TonicNote(Enum):
    c = 'c'
    d = 'd'
    e = 'e'
    f = 'f'
    g = 'g'
    a = 'a'
    b = 'b'


class TonicQuality(Enum):
    major = 'major'
    natural_minor = 'natural_minor'
    harmonic_minor = 'harmonic_minor'
    melodic_minor = 'melodic_minor'
    ionian = 'ionian'
    dorian = 'dorian'
    phrygian = 'phrygian'
    lydian = 'lydian'
    mixolydian = 'mixolydian'
    aeolian = 'aeolian'
    locrian = 'locrian'


class Key(BaseModel):
    tonic_accidental: Optional[TonicAccidental] = Field(
        None,
        description='A text representation of the accidental; if this field is specified, the tonic_note field should also be specified',
    )
    tonic_note: Optional[TonicNote] = Field(
        None,
        description='A text representation of the musical note; if this field is specified, the tonic_accidental field should also be specified',
    )
    tonic_quality: Optional[TonicQuality] = Field(
        None,
        description='The scale quality; if this field is not specified, the API selects the quality automatically',
        examples=['major'],
    )


class Region(Enum):
    music = 'music'
    silence = 'silence'


class AudioRenderTimelineSpanRegion(BaseModel):
    beat: int = Field(
        ...,
        description="The beat, relative to the span, at which the region object's music begins",
    )
    descriptor: str = Field(
        ..., description='The descriptor ID needed to compose the music'
    )
    end_type: Optional[EndType] = Field(
        None, description='A high-level description of how a region ends'
    )
    id: float = Field(
        ..., description='An identifier which must be unique within the parent span'
    )
    key: Optional[Key] = Field(
        None, description='The key signature active at the beginning of the region'
    )
    region: Region = Field(..., description='The type of region')


class AudioRenderTimelineSpanTempoChanges(BaseModel):
    tempo: float = Field(
        ..., description='The tempo, in beats per minute, active at this time'
    )
    time: float = Field(
        ..., description='The time, in seconds, at which the tempo exists'
    )


class AudioRendersFilesList(BaseModel):
    bits_sample: float = Field(
        ..., description='The bit depth of the audio files in bits/sample'
    )
    content_type: str = Field(..., description='The content-type of the file')
    download_url: str = Field(
        ...,
        description='The internet-accessible URL from which the file can be downloaded. Any redirects encountered when using this URL must be followed',
    )
    filename: str = Field(
        ...,
        description='The user-specified file name suggestion from the render request; this file name becomes the filename property of the Content-Disposition header when the user downloads the rendered audio file',
    )
    frequency_hz: float = Field(
        ..., description='The Sample rate of the audio files in Hertz (Hz)'
    )
    kbits_second: float = Field(
        ..., description='The data rate of the audio files in kilobits/second'
    )
    size_bytes: float = Field(..., description='Size of the file in bytes')
    tracks: List[str] = Field(
        ..., description='An array of track names included in the file'
    )


class AudioUrl(BaseModel):
    shorts_loops_stems: Optional[str] = Field(
        None,
        description='URL that can be used to download the .zip file containing shorts, loops, and stems',
    )
    url: str = Field(
        ...,
        description='URL that can be used to download the unwatermarked, licensed asset',
    )


class AuthorizeResponse(RootModel[str]):
    root: str = Field(
        ...,
        description="HTML redirect URL that contains the application authorization 'code'",
        examples=[
            'Moved temporarily. Redirecting to https://accounts.shutterstock.com/login?next=%2Foauth%2Fauthorize%3Fresponse_type%3Dcode%26state%3D1539619928633%26scope%3Dlicenses.create%20licenses.view%20purchases.view%26client_id%3D6d097450b209c6dcd859%26redirect_uri%3Dhttp%3A%2F%2Flocalhost%3A3000%2Fmyapp%2Fauth%2Fcallback%26realm%3Dcustomer'
        ],
    )


class Bands(BaseModel):
    id: Optional[str] = Field(None, description='The ID of the band')
    name: Optional[str] = Field(None, description='The name of the band')


class Visibility(Enum):
    private = 'private'
    public = 'public'


class Type1(Enum):
    image = 'image'
    video = 'video'
    audio = 'audio'
    editorial_image = 'editorial-image'
    editorial_video = 'editorial-video'


class Asset(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    type: Type1


class CatalogCollectionItem(BaseModel):
    asset: Asset
    collection_ids: Optional[List[str]] = Field(
        None, description='The collection IDs that this asset belongs to'
    )
    created_time: datetime
    id: str


class CatalogCollectionItemDataList(BaseModel):
    data: List[CatalogCollectionItem] = Field(
        ..., description='List of catalog collection items'
    )
    page: float
    per_page: float
    total_count: float


class Type2(Enum):
    USER = 'USER'


class CatalogCollectionRole(BaseModel):
    email: str
    id: str
    type: Type2


class Roles(BaseModel):
    editors: Optional[List[CatalogCollectionRole]] = None
    owners: Optional[List[CatalogCollectionRole]] = None
    viewers: Optional[List[CatalogCollectionRole]] = None


class CatalogCollectionRoleAssignments(BaseModel):
    collection_id: str
    roles: Roles


class Category(BaseModel):
    id: Optional[str] = Field(None, description='Category ID')
    name: Optional[str] = Field(None, description='Category name')


class CollectionCreateRequest(BaseModel):
    name: str = Field(..., description='The name of the collection')


class CollectionCreateResponse(BaseModel):
    id: str = Field(..., description='ID of the new collection')


class CollectionItem(BaseModel):
    added_time: Optional[datetime] = Field(
        None, description='The date the item was added to the collection'
    )
    id: str = Field(..., description='ID of the item')
    media_type: Optional[str] = Field(
        None, description='The media type of the item, such as image, video, or audio'
    )


class CollectionItemRequest(BaseModel):
    items: List[CollectionItem] = Field(..., description='List of items')


class CollectionUpdateRequest(BaseModel):
    name: str = Field(..., description='The new name of the collection')


class ComputerVisionImageCreateResponse(BaseModel):
    upload_id: str


class Contributor(BaseModel):
    id: str = Field(..., description='ID of the contributor')


class ContributorProfileSocialMedia(BaseModel):
    facebook: Optional[str] = Field(None, description='Facebook link for contributor')
    google_plus: Optional[str] = Field(None, description='Google+ link for contributor')
    linkedin: Optional[str] = Field(None, description='LinkedIn link for contributor')
    pinterest: Optional[str] = Field(None, description='Pinterest page for contributor')
    tumblr: Optional[str] = Field(None, description='Tumblr link for contributor')
    twitter: Optional[str] = Field(None, description='Twitter link for contributor')


class Cookie(BaseModel):
    name: str = Field(..., description='The name of the cookie')
    value: str = Field(..., description='The value of the cookie')


class Asset1(BaseModel):
    id: Optional[str] = None
    type: str


class CreateCatalogCollectionItem(BaseModel):
    asset: Asset1


class CreateCatalogCollectionItems(BaseModel):
    items: List[CreateCatalogCollectionItem] = Field(..., max_length=50, min_length=1)


class CustomSizeDimensions(BaseModel):
    height: Optional[conint(ge=100)] = Field(
        None, description='Custom height to resize the image to'
    )
    width: Optional[conint(ge=100)] = Field(
        None, description='Custom width to resize the image to'
    )


class DownloadHistoryFormatDetails(BaseModel):
    format: Optional[str] = Field(
        None, description='The format of the downloaded media'
    )
    size: Optional[str] = Field(None, description='The size of the downloaded media')


class DownloadHistoryMediaDetails(BaseModel):
    format: Optional[DownloadHistoryFormatDetails] = None
    id: str = Field(..., description='ID of the download history media details')


class DownloadHistoryRevshareDetails(BaseModel):
    purchase_amount: str = Field(..., description='The amount charged for the license')
    purchase_currency: str = Field(
        ..., description='The currency the amount was charged in'
    )


class DownloadHistoryUserDetails(BaseModel):
    username: str = Field(
        ..., description='The name of the user who downloaded the item'
    )


class EditorialCategory(BaseModel):
    name: Optional[str] = None


class EditorialCategoryResults(BaseModel):
    data: Optional[List[EditorialCategory]] = Field(
        None, description='List of editorial categories'
    )


class EditorialCoverItem(BaseModel):
    height: Optional[int] = None
    id: str
    url: str
    width: Optional[int] = None


class EditorialImageCategoryResults(BaseModel):
    data: Optional[List[EditorialCategory]] = None


class EditorialImageLivefeed(BaseModel):
    cover_item: Optional[EditorialCoverItem] = None
    created_time: Optional[datetime] = Field(
        None, description='When the livefeed was initially created'
    )
    id: str = Field(..., description='Livefeed ID')
    name: str = Field(..., description='Name of the livefeed')
    total_item_count: int = Field(
        ..., description='Total count of items in the livefeed'
    )


class EditorialLivefeed(BaseModel):
    cover_item: Optional[EditorialCoverItem] = None
    created_time: Optional[datetime] = Field(
        None, description='When the livefeed was initially created'
    )
    id: str = Field(..., description='Livefeed ID')
    name: str = Field(..., description='Name of the livefeed')
    total_item_count: int = Field(
        ..., description='Total count of items in the livefeed'
    )


class EditorialLivefeedList(BaseModel):
    data: List[EditorialLivefeed] = Field(..., description='Editorial livefeeds')
    message: Optional[str] = Field(None, description='Optional error message')
    page: Optional[int] = Field(None, description='Current page of the response')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: int = Field(..., description='Total count of all results')


class CommercialStatus(BaseModel):
    reason: Optional[str] = None
    status: Optional[str] = None


class Rights(BaseModel):
    countries: Optional[str] = None


class EditorialVideoCategoryResults(BaseModel):
    data: Optional[List[EditorialCategory]] = None


class Error(BaseModel):
    code: Optional[str] = Field(None, description='The error code of this error')
    data: Optional[str] = Field(
        None, description='Debugging information about the error'
    )
    items: Optional[List[Dict[str, Any]]] = Field(
        None, description='A list of items that produced the error'
    )
    message: str = Field(..., description='Specific details about this error')
    path: Optional[str] = Field(
        None, description='Internal code reference to the source of the error'
    )


class FeaturedCollectionCoverItem(BaseModel):
    url: str = Field(..., description='URL of the collection cover item')


class GenreList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    data: List[str] = Field(..., description='List of genres')


class ISOCountryCode1(Enum):
    ABW = 'ABW'
    AFG = 'AFG'
    AGO = 'AGO'
    AIA = 'AIA'
    ALA = 'ALA'
    ALB = 'ALB'
    AND = 'AND'
    ARE = 'ARE'
    ARG = 'ARG'
    ARM = 'ARM'
    ASM = 'ASM'
    ATA = 'ATA'
    ATF = 'ATF'
    ATG = 'ATG'
    AUS = 'AUS'
    AUT = 'AUT'
    AZE = 'AZE'
    BDI = 'BDI'
    BEL = 'BEL'
    BEN = 'BEN'
    BES = 'BES'
    BFA = 'BFA'
    BGD = 'BGD'
    BGR = 'BGR'
    BHR = 'BHR'
    BHS = 'BHS'
    BIH = 'BIH'
    BLM = 'BLM'
    BLR = 'BLR'
    BLZ = 'BLZ'
    BMU = 'BMU'
    BOL = 'BOL'
    BRA = 'BRA'
    BRB = 'BRB'
    BRN = 'BRN'
    BTN = 'BTN'
    BVT = 'BVT'
    BWA = 'BWA'
    CAF = 'CAF'
    CAN = 'CAN'
    CCK = 'CCK'
    CHE = 'CHE'
    CHL = 'CHL'
    CHN = 'CHN'
    CIV = 'CIV'
    CMR = 'CMR'
    COD = 'COD'
    COG = 'COG'
    COK = 'COK'
    COL = 'COL'
    COM = 'COM'
    CPV = 'CPV'
    CRI = 'CRI'
    CUB = 'CUB'
    CUW = 'CUW'
    CXR = 'CXR'
    CYM = 'CYM'
    CYP = 'CYP'
    CZE = 'CZE'
    DEU = 'DEU'
    DJI = 'DJI'
    DMA = 'DMA'
    DNK = 'DNK'
    DOM = 'DOM'
    DZA = 'DZA'
    ECU = 'ECU'
    EGY = 'EGY'
    ERI = 'ERI'
    ESH = 'ESH'
    ESP = 'ESP'
    EST = 'EST'
    ETH = 'ETH'
    FIN = 'FIN'
    FJI = 'FJI'
    FLK = 'FLK'
    FRA = 'FRA'
    FRO = 'FRO'
    FSM = 'FSM'
    GAB = 'GAB'
    GBR = 'GBR'
    GEO = 'GEO'
    GGY = 'GGY'
    GHA = 'GHA'
    GIB = 'GIB'
    GIN = 'GIN'
    GLP = 'GLP'
    GMB = 'GMB'
    GNB = 'GNB'
    GNQ = 'GNQ'
    GRC = 'GRC'
    GRD = 'GRD'
    GRL = 'GRL'
    GTM = 'GTM'
    GUF = 'GUF'
    GUM = 'GUM'
    GUY = 'GUY'
    HKG = 'HKG'
    HMD = 'HMD'
    HND = 'HND'
    HRV = 'HRV'
    HTI = 'HTI'
    HUN = 'HUN'
    IDN = 'IDN'
    IMN = 'IMN'
    IND = 'IND'
    IOT = 'IOT'
    IRL = 'IRL'
    IRN = 'IRN'
    IRQ = 'IRQ'
    ISL = 'ISL'
    ISR = 'ISR'
    ITA = 'ITA'
    JAM = 'JAM'
    JEY = 'JEY'
    JOR = 'JOR'
    JPN = 'JPN'
    KAZ = 'KAZ'
    KEN = 'KEN'
    KGZ = 'KGZ'
    KHM = 'KHM'
    KIR = 'KIR'
    KNA = 'KNA'
    KOR = 'KOR'
    KWT = 'KWT'
    LAO = 'LAO'
    LBN = 'LBN'
    LBR = 'LBR'
    LBY = 'LBY'
    LCA = 'LCA'
    LIE = 'LIE'
    LKA = 'LKA'
    LSO = 'LSO'
    LTU = 'LTU'
    LUX = 'LUX'
    LVA = 'LVA'
    MAC = 'MAC'
    MAF = 'MAF'
    MAR = 'MAR'
    MCO = 'MCO'
    MDA = 'MDA'
    MDG = 'MDG'
    MDV = 'MDV'
    MEX = 'MEX'
    MHL = 'MHL'
    MKD = 'MKD'
    MLI = 'MLI'
    MLT = 'MLT'
    MMR = 'MMR'
    MNE = 'MNE'
    MNG = 'MNG'
    MNP = 'MNP'
    MOZ = 'MOZ'
    MRT = 'MRT'
    MSR = 'MSR'
    MTQ = 'MTQ'
    MUS = 'MUS'
    MWI = 'MWI'
    MYS = 'MYS'
    MYT = 'MYT'
    NAM = 'NAM'
    NCL = 'NCL'
    NER = 'NER'
    NFK = 'NFK'
    NGA = 'NGA'
    NIC = 'NIC'
    NIU = 'NIU'
    NLD = 'NLD'
    NOR = 'NOR'
    NPL = 'NPL'
    NRU = 'NRU'
    NZL = 'NZL'
    OMN = 'OMN'
    PAK = 'PAK'
    PAN = 'PAN'
    PCN = 'PCN'
    PER = 'PER'
    PHL = 'PHL'
    PLW = 'PLW'
    PNG = 'PNG'
    POL = 'POL'
    PRI = 'PRI'
    PRK = 'PRK'
    PRT = 'PRT'
    PRY = 'PRY'
    PSE = 'PSE'
    PYF = 'PYF'
    QAT = 'QAT'
    REU = 'REU'
    ROU = 'ROU'
    RUS = 'RUS'
    RWA = 'RWA'
    SAU = 'SAU'
    SDN = 'SDN'
    SEN = 'SEN'
    SGP = 'SGP'
    SGS = 'SGS'
    SHN = 'SHN'
    SJM = 'SJM'
    SLB = 'SLB'
    SLE = 'SLE'
    SLV = 'SLV'
    SMR = 'SMR'
    SOM = 'SOM'
    SPM = 'SPM'
    SRB = 'SRB'
    SSD = 'SSD'
    STP = 'STP'
    SUR = 'SUR'
    SVK = 'SVK'
    SVN = 'SVN'
    SWE = 'SWE'
    SWZ = 'SWZ'
    SXM = 'SXM'
    SYC = 'SYC'
    SYR = 'SYR'
    TCA = 'TCA'
    TCD = 'TCD'
    TGO = 'TGO'
    THA = 'THA'
    TJK = 'TJK'
    TKL = 'TKL'
    TKM = 'TKM'
    TLS = 'TLS'
    TON = 'TON'
    TTO = 'TTO'
    TUN = 'TUN'
    TUR = 'TUR'
    TUV = 'TUV'
    TWN = 'TWN'
    TZA = 'TZA'
    UGA = 'UGA'
    UKR = 'UKR'
    UMI = 'UMI'
    URY = 'URY'
    USA = 'USA'
    UZB = 'UZB'
    VAT = 'VAT'
    VCT = 'VCT'
    VEN = 'VEN'
    VGB = 'VGB'
    VIR = 'VIR'
    VNM = 'VNM'
    VUT = 'VUT'
    WLF = 'WLF'
    WSM = 'WSM'
    YEM = 'YEM'
    ZAF = 'ZAF'
    ZMB = 'ZMB'
    ZWE = 'ZWE'


class ISOCountryCode2(Enum):
    AF = 'AF'
    AX = 'AX'
    AL = 'AL'
    DZ = 'DZ'
    AS = 'AS'
    AD = 'AD'
    AO = 'AO'
    AI = 'AI'
    AQ = 'AQ'
    AG = 'AG'
    AR = 'AR'
    AM = 'AM'
    AW = 'AW'
    AU = 'AU'
    AT = 'AT'
    AZ = 'AZ'
    BS = 'BS'
    BH = 'BH'
    BD = 'BD'
    BB = 'BB'
    BY = 'BY'
    BE = 'BE'
    BZ = 'BZ'
    BJ = 'BJ'
    BM = 'BM'
    BT = 'BT'
    BO = 'BO'
    BA = 'BA'
    BW = 'BW'
    BV = 'BV'
    BR = 'BR'
    IO = 'IO'
    BN = 'BN'
    BG = 'BG'
    BF = 'BF'
    BI = 'BI'
    KH = 'KH'
    CM = 'CM'
    CA = 'CA'
    CV = 'CV'
    KY = 'KY'
    CF = 'CF'
    TD = 'TD'
    CL = 'CL'
    CN = 'CN'
    CX = 'CX'
    CC = 'CC'
    CO = 'CO'
    KM = 'KM'
    CG = 'CG'
    CD = 'CD'
    CK = 'CK'
    CR = 'CR'
    CI = 'CI'
    HR = 'HR'
    CU = 'CU'
    CY = 'CY'
    CZ = 'CZ'
    DK = 'DK'
    DJ = 'DJ'
    DM = 'DM'
    DO = 'DO'
    EC = 'EC'
    EG = 'EG'
    SV = 'SV'
    GQ = 'GQ'
    ER = 'ER'
    EE = 'EE'
    ET = 'ET'
    FK = 'FK'
    FO = 'FO'
    FJ = 'FJ'
    FI = 'FI'
    FR = 'FR'
    GF = 'GF'
    PF = 'PF'
    TF = 'TF'
    GA = 'GA'
    GM = 'GM'
    GE = 'GE'
    DE = 'DE'
    GH = 'GH'
    GI = 'GI'
    GR = 'GR'
    GL = 'GL'
    GD = 'GD'
    GP = 'GP'
    GU = 'GU'
    GT = 'GT'
    GG = 'GG'
    GN = 'GN'
    GW = 'GW'
    GY = 'GY'
    HT = 'HT'
    HM = 'HM'
    VA = 'VA'
    HN = 'HN'
    HK = 'HK'
    HU = 'HU'
    IS = 'IS'
    IN = 'IN'
    ID = 'ID'
    IR = 'IR'
    IQ = 'IQ'
    IE = 'IE'
    IM = 'IM'
    IL = 'IL'
    IT = 'IT'
    JM = 'JM'
    JP = 'JP'
    JE = 'JE'
    JO = 'JO'
    KZ = 'KZ'
    KE = 'KE'
    KI = 'KI'
    KR = 'KR'
    KW = 'KW'
    KG = 'KG'
    LA = 'LA'
    LV = 'LV'
    LB = 'LB'
    LS = 'LS'
    LR = 'LR'
    LY = 'LY'
    LI = 'LI'
    LT = 'LT'
    LU = 'LU'
    MO = 'MO'
    MK = 'MK'
    MG = 'MG'
    MW = 'MW'
    MY = 'MY'
    MV = 'MV'
    ML = 'ML'
    MT = 'MT'
    MH = 'MH'
    MQ = 'MQ'
    MR = 'MR'
    MU = 'MU'
    YT = 'YT'
    MX = 'MX'
    FM = 'FM'
    MD = 'MD'
    MC = 'MC'
    MN = 'MN'
    ME = 'ME'
    MS = 'MS'
    MA = 'MA'
    MZ = 'MZ'
    MM = 'MM'
    NA = 'NA'
    NR = 'NR'
    NP = 'NP'
    NL = 'NL'
    AN = 'AN'
    NC = 'NC'
    NZ = 'NZ'
    NI = 'NI'
    NE = 'NE'
    NG = 'NG'
    NU = 'NU'
    NF = 'NF'
    MP = 'MP'
    NO = 'NO'
    OM = 'OM'
    PK = 'PK'
    PW = 'PW'
    PS = 'PS'
    PA = 'PA'
    PG = 'PG'
    PY = 'PY'
    PE = 'PE'
    PH = 'PH'
    PN = 'PN'
    PL = 'PL'
    PT = 'PT'
    PR = 'PR'
    QA = 'QA'
    RE = 'RE'
    RO = 'RO'
    RU = 'RU'
    RW = 'RW'
    BL = 'BL'
    SH = 'SH'
    KN = 'KN'
    LC = 'LC'
    MF = 'MF'
    PM = 'PM'
    VC = 'VC'
    WS = 'WS'
    SM = 'SM'
    ST = 'ST'
    SA = 'SA'
    SN = 'SN'
    RS = 'RS'
    SC = 'SC'
    SL = 'SL'
    SG = 'SG'
    SK = 'SK'
    SI = 'SI'
    SB = 'SB'
    SO = 'SO'
    ZA = 'ZA'
    GS = 'GS'
    ES = 'ES'
    LK = 'LK'
    SD = 'SD'
    SR = 'SR'
    SJ = 'SJ'
    SZ = 'SZ'
    SE = 'SE'
    CH = 'CH'
    SY = 'SY'
    TW = 'TW'
    TJ = 'TJ'
    TZ = 'TZ'
    TH = 'TH'
    TL = 'TL'
    TG = 'TG'
    TK = 'TK'
    TO = 'TO'
    TT = 'TT'
    TN = 'TN'
    TR = 'TR'
    TM = 'TM'
    TC = 'TC'
    TV = 'TV'
    UG = 'UG'
    UA = 'UA'
    AE = 'AE'
    GB = 'GB'
    US = 'US'
    UM = 'UM'
    UY = 'UY'
    UZ = 'UZ'
    VU = 'VU'
    VE = 'VE'
    VN = 'VN'
    VG = 'VG'
    VI = 'VI'
    WF = 'WF'
    EH = 'EH'
    YE = 'YE'
    ZM = 'ZM'
    ZW = 'ZW'


class ISOCountryCode(RootModel[Union[ISOCountryCode1, ISOCountryCode2]]):
    root: Union[ISOCountryCode1, ISOCountryCode2] = Field(
        ...,
        description='A valid ISO 3166-1 Alpha-2 or ISO 3166-1 Alpha-3 code.',
        examples=['USA'],
    )


class Insights(BaseModel):
    labels: Optional[List[str]] = None


class ImageCreateRequest(BaseModel):
    base64_image: str = Field(
        ...,
        description='A Base 64 encoded jpeg or png; images can be no larger than 10mb and can be no larger than 10,000 pixels in width or height',
    )


class ImageCreateResponse(BaseModel):
    id: str


class ImageSizeDetails(BaseModel):
    display_name: Optional[str] = Field(
        None, description='Display name of this image size'
    )
    dpi: Optional[int] = None
    file_size: Optional[int] = Field(
        None, description='File size (in bytes) of this image size'
    )
    format: Optional[str] = Field(None, description='Format of this image size')
    height: Optional[int] = Field(None, description='Height of this image size')
    is_licensable: Optional[bool] = Field(
        None, description='Whether or not this image can be licensed in this image size'
    )
    width: Optional[int] = Field(None, description='Width of this image size')


class LabelPerformanceItem(BaseModel):
    name: Optional[str] = None
    percentile_performance: Optional[float] = None


class InsightsModel(BaseModel):
    label_performance: List[LabelPerformanceItem] = Field(
        ...,
        description='How effective the AI thinks an asset in the category is for the specified audience and objective, expressed as a percentile compared to other images',
    )


class InstrumentList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    data: List[str] = Field(..., description='List of instruments')


class Instruments(BaseModel):
    id: Optional[str] = Field(None, description='The string id of the instrument')
    name: Optional[str] = Field(None, description='The string name of the instrument')


class KeywordDataList(BaseModel):
    data: Optional[List[str]] = Field(None, description='Keywords')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')


class Language(Enum):
    ar = 'ar'
    bg = 'bg'
    bn = 'bn'
    cs = 'cs'
    da = 'da'
    de = 'de'
    el = 'el'
    en = 'en'
    es = 'es'
    fi = 'fi'
    fr = 'fr'
    gu = 'gu'
    he = 'he'
    hi = 'hi'
    hr = 'hr'
    hu = 'hu'
    id = 'id'
    it = 'it'
    ja = 'ja'
    kn = 'kn'
    ko = 'ko'
    ml = 'ml'
    mr = 'mr'
    nb = 'nb'
    nl = 'nl'
    or_ = 'or'
    pl = 'pl'
    pt = 'pt'
    ro = 'ro'
    ru = 'ru'
    sk = 'sk'
    sl = 'sl'
    sv = 'sv'
    ta = 'ta'
    te = 'te'
    th = 'th'
    tr = 'tr'
    uk = 'uk'
    ur = 'ur'
    vi = 'vi'
    zh = 'zh'
    zh_Hant = 'zh-Hant'


class License(Enum):
    audio_platform = 'audio_platform'
    premier_music_basic = 'premier_music_basic'
    premier_music_extended = 'premier_music_extended'
    premier_music_pro = 'premier_music_pro'
    premier_music_comp = 'premier_music_comp'
    asset_all_music = 'asset_all_music'


class LicenseAudio(BaseModel):
    audio_id: str = Field(..., description='ID of the track being licensed')
    license: Optional[License] = Field(None, description='Type of license')
    search_id: Optional[str] = Field(
        None, description='ID of the search that led to this licensing event'
    )


class LicenseAudioRequest(BaseModel):
    audio: List[LicenseAudio] = Field(
        ..., description='List of audio tracks to license', max_length=50
    )


class LicenseAudioResult(BaseModel):
    allotment_charge: Optional[float] = Field(
        None, description='Number of credits that this licensing event used'
    )
    audio_id: str = Field(..., description='ID of the track that was licensed')
    download: Optional[AudioUrl] = None
    error: Optional[str] = Field(None, description='Error information if applicable')
    license_id: Optional[str] = Field(None, description='ID of the license event')


class LicenseAudioResultDataList(BaseModel):
    data: Optional[List[LicenseAudioResult]] = Field(
        None, description='License results'
    )
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(
        None, description='Total count of all results across all pages'
    )


class Size(Enum):
    small = 'small'
    medium = 'medium'
    original = 'original'


class License1(Enum):
    premier_editorial_video_digital_only = 'premier_editorial_video_digital_only'
    premier_editorial_video_all_media = 'premier_editorial_video_all_media'
    premier_editorial_video_all_media_single_territory = (
        'premier_editorial_video_all_media_single_territory'
    )
    premier_editorial_video_comp = 'premier_editorial_video_comp'


class Size1(Enum):
    original = 'original'


class MediaType(Enum):
    image = 'image'
    video = 'video'
    audio = 'audio'
    editorial = 'editorial'


class LicenseFormat(BaseModel):
    description: Optional[str] = Field(None, description='Description of the license')
    format: Optional[str] = Field(
        None,
        description='Format or extension of the media, such as mpeg for videos or jpeg for images',
    )
    media_type: Optional[MediaType] = Field(
        None, description='Media type of the license'
    )
    min_resolution: Optional[int] = Field(
        None, description='Width of the media, in pixels, allowed by this license'
    )
    size: Optional[str] = Field(
        None,
        description='Keyword that details the size of the media, such as hd or sd for video, huge or vector for images',
    )


class Format(Enum):
    jpg = 'jpg'


class Size2(Enum):
    small = 'small'
    medium = 'medium'
    huge = 'huge'
    custom = 'custom'


class Format1(Enum):
    eps = 'eps'


class Size3(Enum):
    vector = 'vector'


class LicenseRequestMetadata(BaseModel):
    pass


class AudioLayout(Enum):
    ambisonic = 'ambisonic'
    field_5_1 = '5.1'
    stereo = 'stereo'


class Format2(Enum):
    wav = 'wav'
    mp3 = 'mp3'


class LicenseSFX(BaseModel):
    audio_layout: Optional[AudioLayout] = None
    format: Optional[Format2] = None
    search_id: Optional[str] = Field(
        None, description='ID of the search that led to this licensing event'
    )
    sfx_id: str = Field(..., description='ID of the sounds effect being licensed')
    subscription_id: str = Field(
        ..., description='ID of the subscription to use for the download.'
    )


class LicenseSFXRequest(BaseModel):
    sound_effects: List[LicenseSFX] = Field(
        ..., description='Sound effects to license for'
    )


class Size4(Enum):
    web = 'web'
    sd = 'sd'
    hd = 'hd'
    field_4k = '4k'


class LicenseVideo(BaseModel):
    auth_cookie: Optional[Cookie] = None
    editorial_acknowledgement: Optional[bool] = Field(
        None, description='Whether or not this item is editorial content'
    )
    metadata: Optional[LicenseRequestMetadata] = None
    price: Optional[float] = Field(
        None,
        description='Retail price amount as a floating-point number in the transaction currency, such as 12.34; only for rev-share partners',
    )
    search_id: Optional[str] = Field(
        None, description='ID of the search that led to this licensing event'
    )
    show_modal: Optional[bool] = Field(None, description='(Deprecated)')
    size: Optional[Size4] = Field(None, description='Size of the video being licensed')
    subscription_id: Optional[str] = Field(
        None, description='ID of the subscription used for this license'
    )
    video_id: str = Field(..., description='ID of the video being licensed')


class LicenseVideoRequest(BaseModel):
    videos: List[LicenseVideo] = Field(
        ..., description='Videos to license', max_length=50
    )


class Model(BaseModel):
    id: str = Field(..., description='ID of the model')


class ModelRelease(BaseModel):
    id: Optional[str] = Field(None, description='ID of the model or property release')


class MoodList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    data: List[str] = Field(..., description='List of audio moods')


class OauthAccessTokenResponse(BaseModel):
    access_token: str = Field(
        ..., description='Access token that can be used for future requests'
    )
    expires_in: Optional[int] = Field(
        None,
        description='Number of seconds before token expires, only present for expiring tokens',
    )
    refresh_token: Optional[str] = Field(
        None,
        description='A refresh token that can be used to renew the access_token when it expires, only present for expiring tokens',
    )
    token_type: str = Field(..., description='Type of token')
    user_token: Optional[str] = Field(
        None,
        description='Metadata about the access_token, only present for expiring tokens',
    )


class ContentType(Enum):
    audio_mp3 = 'audio/mp3'


class Preview(BaseModel):
    content_type: Optional[ContentType] = Field(
        None, description='Content type of the preview, currently audio/mp3'
    )
    url: Optional[str] = Field(None, description="Url of the instrument's preview file")


class Price(BaseModel):
    local_amount: Optional[float] = Field(
        None,
        description='Floating-point amount of the calculated rev-share price in the currency local_currency',
    )
    local_currency: Optional[str] = Field(
        None, description='Currency of the rev-share price that was calculated'
    )


class Recommendation(BaseModel):
    id: str = Field(..., description='Media ID')


class RecommendationDataList(BaseModel):
    data: Optional[List[Recommendation]] = Field(None, description='Recommended images')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(
        None, description='Total count of all results across all pages'
    )


class Size5(Enum):
    small = 'small'
    medium = 'medium'
    huge = 'huge'
    supersize = 'supersize'
    vector = 'vector'


class RedownloadImage(BaseModel):
    auth_cookie: Optional[Cookie] = Field(None, description='(Deprecated)')
    show_modal: Optional[bool] = Field(None, description='(Deprecated)')
    size: Optional[Size5] = Field(None, description='Size of the image')
    verification_code: Optional[str] = Field(None, description='(Deprecated)')


class Size6(Enum):
    web = 'web'
    sd = 'sd'
    hd = 'hd'
    field_4k = '4k'


class RedownloadVideo(BaseModel):
    auth_cookie: Optional[Cookie] = Field(None, description='(Deprecated)')
    show_modal: Optional[bool] = Field(None, description='(Deprecated)')
    size: Optional[Size6] = Field(None, description='Size of the video')
    verification_code: Optional[str] = Field(None, description='(Deprecated)')


class RemoveCatalogCollectionItem(BaseModel):
    id: str


class RemoveCatalogCollectionItems(BaseModel):
    items: List[RemoveCatalogCollectionItem] = Field(..., max_length=50, min_length=1)


class SFXAssetDetails(BaseModel):
    file_size: Optional[int] = Field(None, description='File size of the sound effect')
    url: Optional[str] = Field(None, description='URL the sound effect is available at')


class SFXAssets(BaseModel):
    preview_mp3: Optional[SFXAssetDetails] = None
    waveform: Optional[SFXAssetDetails] = None


class SearchEntitiesRequest(BaseModel):
    text: constr(min_length=1, max_length=100000) = Field(
        ..., description='Plain text to extract keywords from'
    )


class SearchEntitiesResponse(BaseModel):
    keywords: Optional[List[str]] = Field(
        None, description='The top keywords from the submitted text'
    )


class ImageTypeEnum(Enum):
    photo = 'photo'
    illustration = 'illustration'
    vector = 'vector'


class LicenseEnum(Enum):
    commercial = 'commercial'
    editorial = 'editorial'
    enhanced = 'enhanced'


class Orientation(Enum):
    horizontal = 'horizontal'
    vertical = 'vertical'


class PeopleAge(Enum):
    infants = 'infants'
    children = 'children'
    teenagers = 'teenagers'
    field_20s = '20s'
    field_30s = '30s'
    field_40s = '40s'
    field_50s = '50s'
    field_60s = '60s'
    older = 'older'


class PeopleEthnicityEnum(Enum):
    african = 'african'
    african_american = 'african_american'
    black = 'black'
    brazilian = 'brazilian'
    chinese = 'chinese'
    caucasian = 'caucasian'
    east_asian = 'east_asian'
    hispanic = 'hispanic'
    japanese = 'japanese'
    middle_eastern = 'middle_eastern'
    native_american = 'native_american'
    pacific_islander = 'pacific_islander'
    south_asian = 'south_asian'
    southeast_asian = 'southeast_asian'
    other = 'other'
    NOT_african = 'NOT african'
    NOT_african_american = 'NOT african_american'
    NOT_black = 'NOT black'
    NOT_brazilian = 'NOT brazilian'
    NOT_chinese = 'NOT chinese'
    NOT_caucasian = 'NOT caucasian'
    NOT_east_asian = 'NOT east_asian'
    NOT_hispanic = 'NOT hispanic'
    NOT_japanese = 'NOT japanese'
    NOT_middle_eastern = 'NOT middle_eastern'
    NOT_native_american = 'NOT native_american'
    NOT_pacific_islander = 'NOT pacific_islander'
    NOT_south_asian = 'NOT south_asian'
    NOT_southeast_asian = 'NOT southeast_asian'
    NOT_other = 'NOT other'


class PeopleGender(Enum):
    male = 'male'
    female = 'female'
    both = 'both'


class Sort(Enum):
    newest = 'newest'
    popular = 'popular'
    relevance = 'relevance'
    random = 'random'


class View(Enum):
    minimal = 'minimal'
    full = 'full'


class SearchImage(BaseModel):
    added_date: Optional[date] = Field(
        None, description='Show images added on the specified date'
    )
    added_date_end: Optional[date] = Field(
        None, description='Show images added before the specified date'
    )
    added_date_start: Optional[date] = Field(
        None, description='Show images added on or after the specified date'
    )
    aspect_ratio: Optional[float] = Field(
        None,
        description='Show images with the specified aspect ratio, using a positive decimal of the width divided by the height, such as 1.7778 for a 16:9 image',
    )
    aspect_ratio_max: Optional[confloat(ge=0.0)] = Field(
        None,
        description='Show images with the specified aspect ratio or lower, using a positive decimal of the width divided by the height, such as 1.7778 for a 16:9 image',
    )
    aspect_ratio_min: Optional[confloat(ge=0.0)] = Field(
        None,
        description='Show images with the specified aspect ratio or higher, using a positive decimal of the width divided by the height, such as 1.7778 for a 16:9 image',
    )
    authentic: Optional[bool] = Field(None, description='Show only authentic images')
    category: Optional[str] = Field(
        None,
        description='Show images with the specified Shutterstock-defined category; specify a category name or ID',
    )
    color: Optional[str] = Field(
        None,
        description="Specify either a hexadecimal color in the format '4F21EA' or 'grayscale'; the API returns images that use similar colors",
    )
    contributor: Optional[List[str]] = Field(
        None,
        description='Show images with the specified contributor names or IDs, allows multiple',
    )
    contributor_country: Optional[List[str]] = Field(
        None,
        description='Show images from contributors in one or more specified countries, or start with NOT to exclude a country from the search',
    )
    fields: Optional[str] = Field(
        None,
        description='Fields to display in the response; see the documentation for the fields parameter in the overview section',
    )
    height: Optional[int] = Field(
        None,
        description='(Deprecated; use height_from and height_to instead) Show images with the specified height',
    )
    height_from: Optional[int] = Field(
        None, description='Show images with the specified height or larger, in pixels'
    )
    height_to: Optional[int] = Field(
        None, description='Show images with the specified height or smaller, in pixels'
    )
    image_type: Optional[List[ImageTypeEnum]] = Field(
        None, description='Show images of the specified type'
    )
    keyword_safe_search: Optional[bool] = Field(
        True, description='Hide results with potentially unsafe keywords'
    )
    language: Optional[Language] = Field(
        None,
        description='Set query and result language (uses Accept-Language header if not set)',
    )
    license: Optional[List[LicenseEnum]] = Field(
        ['commercial'], description='Show only images with the specified license'
    )
    model: Optional[List[str]] = Field(
        None, description='Show image results with the specified model IDs'
    )
    orientation: Optional[Orientation] = Field(
        None, description='Show image results with horizontal or vertical orientation'
    )
    page: Optional[conint(ge=1)] = Field(1, description='Page number')
    people_age: Optional[PeopleAge] = Field(
        None,
        description='Show images that feature people of the specified age category',
    )
    people_ethnicity: Optional[List[PeopleEthnicityEnum]] = Field(
        None,
        description='Show images with people of the specified ethnicities, or start with NOT to show images without those ethnicities',
    )
    people_gender: Optional[PeopleGender] = Field(
        None, description='Show images with people of the specified gender'
    )
    people_model_released: Optional[bool] = Field(
        None, description='Show images of people with a signed model release'
    )
    people_number: Optional[conint(ge=0, le=4)] = Field(
        None, description='Show images with the specified number of people'
    )
    per_page: Optional[conint(ge=0, le=20)] = Field(
        20, description='Number of results per page'
    )
    query: Optional[str] = Field(
        None,
        description='One or more search terms separated by spaces; you can use NOT to filter out images that match a term',
    )
    region: Optional[Union[str, IPv4Address]] = Field(
        None,
        description="Raise or lower search result rankings based on the result's relevance to a specified region; you can provide a country code or an IP address from which the API infers a country",
    )
    safe: Optional[bool] = Field(True, description='Enable or disable safe search')
    sort: Optional[Sort] = Field('popular', description='Sort by')
    spellcheck_query: Optional[bool] = Field(
        True,
        description='Spellcheck the search query and return results on suggested spellings',
    )
    view: Optional[View] = Field(
        'minimal', description='Amount of detail to render in the response'
    )
    width: Optional[int] = Field(
        None,
        description='(Deprecated; use width_from and width_to instead) Show images with the specified width',
    )
    width_from: Optional[int] = Field(
        None, description='Show images with the specified width or larger, in pixels'
    )
    width_to: Optional[int] = Field(
        None, description='Show images with the specified width or smaller, in pixels'
    )


class SfxUrl(BaseModel):
    url: str = Field(
        ...,
        description='URL that can be used to download the unwatermarked, licensed asset',
    )


class ShortsLoopsStems(BaseModel):
    loops: Optional[Any] = None
    shorts: Optional[Any] = None
    stems: Optional[Any] = None


class SubscriptionMetadata(BaseModel):
    pass


class Suggestions(BaseModel):
    data: Optional[List[str]] = Field(None, description='Search suggestions')


class TestEcho(BaseModel):
    text: Optional[str] = None


class TestValidateHeader(BaseModel):
    user_agent: Optional[str] = Field(
        None, alias='user-agent', description='User agent to expect in the response'
    )


class TestValidateQuery(BaseModel):
    id: int = Field(..., description='Integer ID that was passed in the request')
    tag: Optional[List[str]] = Field(
        None, description='List of tags that were passed in the request'
    )


class Thumbnail(BaseModel):
    height: int = Field(..., description='Height in pixels of the image thumbnail')
    url: str = Field(..., description='Direct URL to the image')
    width: int = Field(..., description='Width in pixels of the image thumbnail')


class CoverAsset(BaseModel):
    id: str


class UpdateCatalogCollection(BaseModel):
    cover_asset: Optional[CoverAsset] = None
    name: Optional[constr(min_length=1, max_length=100000)] = None
    visibility: Optional[Visibility] = None


class UpdatedMedia(BaseModel):
    id: str = Field(..., description='ID of the media')
    updated_time: datetime = Field(..., description='Date that the media was updated')
    updates: List[str] = Field(
        ..., description='Types of updates that were made to the piece of media'
    )


class UpdatedMediaDataList(BaseModel):
    data: Optional[List[UpdatedMedia]] = Field(None, description='Updated media items')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(
        None, description='Total count of all results across all pages'
    )


class Url(BaseModel):
    url: str = Field(
        ...,
        description='URL that can be used to download the unwatermarked, licensed asset',
    )


class Urls(BaseModel):
    urls: List[str] = Field(..., description='URLs')


class UserDetails(BaseModel):
    contributor_id: Optional[str] = Field(
        None, description='Unique internal identifier of the user, as a contributor'
    )
    customer_id: Optional[str] = Field(
        None, description='Unique internal identifier of the user, as a purchaser'
    )
    email: Optional[str] = Field(None, description='Email address of the user')
    first_name: Optional[str] = Field(None, description='First name of the user')
    full_name: Optional[str] = Field(
        None, description='Full name including first, middle, and last name of the user'
    )
    id: Optional[str] = Field(
        None,
        description='Unique internal identifier for the user, not tied to contributor or purchasing customer',
    )
    is_premier: Optional[bool] = Field(
        None,
        description='True if the user has access to the Premier collection, false otherwise',
    )
    is_premier_parent: Optional[bool] = Field(
        None,
        description='True if the user has access to the Premier collection and also has child users',
    )
    language: Optional[str] = Field(
        None, description='Main language of the user account'
    )
    last_name: Optional[str] = Field(None, description='Last name of the user')
    only_enhanced_license: Optional[bool] = Field(
        None, description='True if the user has an enterprise license, false otherwise'
    )
    only_sensitive_use: Optional[bool] = Field(
        None,
        description='True if the user has access to sensitive use only, false otherwise',
    )
    organization_id: Optional[str] = Field(
        None,
        description="Unique internal identifier for the user's organization, specific to Premier users",
    )
    premier_permissions: Optional[List[str]] = Field(
        None, description='List of permissions allowed through the Premier client'
    )
    username: Optional[str] = Field(
        None, description='User name associated to the user'
    )


class VideoCollectionItemDataList(BaseModel):
    data: Optional[List[CollectionItem]] = Field(
        None, description='Assets in the collection'
    )
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='The current page of results')
    per_page: Optional[int] = Field(None, description='The number of results per page')
    total_count: Optional[int] = Field(
        None, description='The total number of results across all pages'
    )


class VideoPreviewUrl(BaseModel):
    url: str = Field(..., description='Direct URL to the image')


class VideoSizeDetails(BaseModel):
    display_name: Optional[str] = Field(
        None, description='Display name of this video size'
    )
    file_size: Optional[int] = Field(
        None, description='File size (in bytes) of this video size'
    )
    format: Optional[str] = Field(None, description='Format of this video size')
    fps: Optional[float] = Field(
        None, description='Frames per second of this video size'
    )
    height: Optional[int] = Field(None, description='Height of this video size')
    is_licensable: Optional[bool] = Field(
        None, description='Whether or not videos can be licensed in this video size'
    )
    width: Optional[int] = Field(None, description='Width of this video size')


class Id(RootModel[List[str]]):
    root: List[str] = Field(..., max_length=20)


class Id1(RootModel[List[str]]):
    root: List[str]


class IdItem(RootModel[constr(pattern=r'^[1-9]\d*$')]):
    root: constr(pattern=r'^[1-9]\d*$')


class Id3(RootModel[List[IdItem]]):
    root: List[IdItem] = Field(..., max_length=500, min_length=1)


class EmbedEnum(Enum):
    share_code = 'share_code'
    share_url = 'share_url'


class Embed(RootModel[List[EmbedEnum]]):
    root: List[EmbedEnum]


class Embed1(RootModel[List[EmbedEnum]]):
    root: List[EmbedEnum]


class ItemId(RootModel[List[str]]):
    root: List[str]


class Sort1(Enum):
    newest = 'newest'
    oldest = 'oldest'


class DownloadAvailability(Enum):
    all = 'all'
    downloadable = 'downloadable'
    non_downloadable = 'non_downloadable'


class License2(Enum):
    audio_platform = 'audio_platform'
    premier_music_basic = 'premier_music_basic'
    premier_music_extended = 'premier_music_extended'
    premier_music_pro = 'premier_music_pro'
    premier_music_comp = 'premier_music_comp'
    asset_all_music = 'asset_all_music'


class Sort5(Enum):
    score = 'score'
    ranking_all = 'ranking_all'
    artist = 'artist'
    title = 'title'
    bpm = 'bpm'
    freshness = 'freshness'
    duration = 'duration'


class SortOrder(Enum):
    asc = 'asc'
    desc = 'desc'


class Library(Enum):
    shutterstock = 'shutterstock'
    premier = 'premier'


class Artists(RootModel[List[str]]):
    root: List[str]


class Genre(RootModel[List[str]]):
    root: List[str]


class Instruments1(RootModel[List[str]]):
    root: List[str]


class Moods(RootModel[List[str]]):
    root: List[str]


class Sort7(Enum):
    newest = 'newest'
    popular = 'popular'
    relevance = 'relevance'
    random = 'random'


class Contributor1(RootModel[List[str]]):
    root: List[str]


class ContributorCountry(RootModel[List[str]]):
    root: List[str]


class ImageType(RootModel[List[ImageTypeEnum]]):
    root: List[ImageTypeEnum]


class License4(RootModel[List[LicenseEnum]]):
    root: List[LicenseEnum]


class Model1(RootModel[List[str]]):
    root: List[str]


class PeopleEthnicity(RootModel[List[PeopleEthnicityEnum]]):
    root: List[PeopleEthnicityEnum]


class Region1(RootModel[Union[str, IPv4Address]]):
    root: Union[str, IPv4Address]


class Sort9(Enum):
    newest = 'newest'
    oldest = 'oldest'


class AssetTypeEnum(Enum):
    image = 'image'
    video = 'video'
    audio = 'audio'
    elements = 'elements'
    editorial_image = 'editorial-image'
    editorial_video = 'editorial-video'


class CollectionId(RootModel[List[str]]):
    root: List[str] = Field(
        ..., examples=[['123456', '456789', '13579']], max_length=50
    )


class AssetType(RootModel[List[AssetTypeEnum]]):
    root: List[AssetTypeEnum] = Field(..., examples=[['image', 'editorial-image']])


class Id4(RootModel[List[str]]):
    root: List[str]


class Sort13(Enum):
    newest = 'newest'
    last_updated = 'last_updated'
    item_count = 'item_count'


class Sort15(Enum):
    newest = 'newest'
    oldest = 'oldest'


class AssetId(RootModel[str]):
    root: str


class LicenseEnum3(Enum):
    commercial = 'commercial'
    editorial = 'editorial'


class License5(RootModel[List[LicenseEnum3]]):
    root: List[LicenseEnum3]


class License6(RootModel[List[LicenseEnum3]]):
    root: List[LicenseEnum3]


class Sort19(Enum):
    relevant = 'relevant'
    newest = 'newest'
    oldest = 'oldest'


class SupplierCode(RootModel[List[str]]):
    root: List[str]


class Type3(Enum):
    edit = 'edit'
    addition = 'addition'


class Sort21(Enum):
    newest = 'newest'
    oldest = 'oldest'


class SupplierCode1(RootModel[List[constr(max_length=5)]]):
    root: List[constr(max_length=5)]


class Sort23(Enum):
    relevant = 'relevant'
    newest = 'newest'
    oldest = 'oldest'


class SupplierCode2(RootModel[List[str]]):
    root: List[str]


class Sort25(Enum):
    newest = 'newest'
    oldest = 'oldest'


class SupplierCode3(RootModel[List[constr(max_length=5)]]):
    root: List[constr(max_length=5)]


class Sort29(Enum):
    relevant = 'relevant'
    newest = 'newest'
    oldest = 'oldest'


class Resolution(Enum):
    field_4k = '4k'
    high_definition = 'high_definition'
    standard_definition = 'standard_definition'


class SupplierCode4(RootModel[List[str]]):
    root: List[str]


class Id5(RootModel[List[str]]):
    root: List[str] = Field(..., max_length=500)


class Embed2(RootModel[List[EmbedEnum]]):
    root: List[EmbedEnum]


class Embed3(Enum):
    share_url = 'share_url'


class TypeEnum(Enum):
    photo = 'photo'
    editorial = 'editorial'
    vector = 'vector'


class AssetHint(Enum):
    field_1x = '1x'
    field_2x = '2x'


class Type7(RootModel[List[TypeEnum]]):
    root: List[TypeEnum]


class Embed7(RootModel[List[EmbedEnum]]):
    root: List[EmbedEnum]


class Sort31(Enum):
    newest = 'newest'
    oldest = 'oldest'


class Format3(Enum):
    eps = 'eps'
    jpg = 'jpg'


class Size7(Enum):
    small = 'small'
    medium = 'medium'
    huge = 'huge'
    vector = 'vector'
    custom = 'custom'


class Id6(RootModel[List[str]]):
    root: List[str]


class AiIndustry(Enum):
    automotive = 'automotive'
    cpg = 'cpg'
    finance = 'finance'
    healthcare = 'healthcare'
    retail = 'retail'
    technology = 'technology'


class AiObjective(Enum):
    awareness = 'awareness'
    traffic = 'traffic'
    conversions = 'conversions'


class LicenseEnum7(Enum):
    commercial = 'commercial'
    editorial = 'editorial'
    enhanced = 'enhanced'


class Sort35(Enum):
    newest = 'newest'
    popular = 'popular'
    relevance = 'relevance'
    random = 'random'


class ImageType1(RootModel[List[ImageTypeEnum]]):
    root: List[ImageTypeEnum]


class License7(RootModel[List[LicenseEnum7]]):
    root: List[LicenseEnum7]


class PeopleEthnicity1(RootModel[List[PeopleEthnicityEnum]]):
    root: List[PeopleEthnicityEnum]


class TypeEnum2(Enum):
    addition = 'addition'
    deletion = 'deletion'
    edit = 'edit'


class Sort37(Enum):
    newest = 'newest'
    oldest = 'oldest'


class Type8(RootModel[List[TypeEnum2]]):
    root: List[TypeEnum2]


class GrantType(Enum):
    authorization_code = 'authorization_code'
    client_credentials = 'client_credentials'
    refresh_token = 'refresh_token'


class V2OauthAccessTokenPostRequest(BaseModel):
    client_id: str = Field(
        ..., description='Client ID (Consumer Key) of your application'
    )
    client_secret: Optional[str] = Field(
        None, description='Client Secret (Consumer Secret) of your application'
    )
    code: Optional[str] = Field(
        None,
        description='Response code from the /oauth/authorize flow; required if grant_type=authorization_code',
    )
    expires: Optional[bool] = Field(
        False,
        description='Whether or not the token expires, expiring tokens come with a refresh_token to renew the access_token',
    )
    grant_type: GrantType = Field(
        ...,
        description='Grant type: authorization_code generates user tokens, client_credentials generates short-lived client grants',
    )
    realm: Optional[Realm] = Field(
        'customer', description="User type to be authorized (usually 'customer')"
    )
    refresh_token: Optional[str] = Field(
        None,
        description='Pass this along with grant_type=refresh_token to get a fresh access token',
    )


class Expires(Enum):
    true = 'true'
    false = 'false'


class V2OauthAccessTokenPostRequest1(BaseModel):
    client_id: str = Field(
        ..., description='Client ID (Consumer Key) of your application'
    )
    client_secret: Optional[str] = Field(
        None, description='Client Secret (Consumer Secret) of your application'
    )
    code: Optional[str] = Field(
        None,
        description='Response code from the /oauth/authorize flow; required if grant_type=authorization_code',
    )
    expires: Optional[Expires] = Field(
        'false',
        description='Whether or not the token expires, expiring tokens come with a refresh_token to renew the access_token',
    )
    grant_type: GrantType = Field(
        ...,
        description='Grant type: authorization_code generates user tokens, client_credentials generates short-lived client grants',
    )
    realm: Optional[Realm] = Field(
        'customer', description="User type to be authorized (usually 'customer')"
    )
    refresh_token: Optional[str] = Field(
        None,
        description='Pass this along with grant_type=refresh_token to get a fresh access token',
    )


class ResponseType(Enum):
    code = 'code'


class Library2(Enum):
    shutterstock = 'shutterstock'
    premier = 'premier'
    premiumbeat = 'premiumbeat'


class Id7(RootModel[List[str]]):
    root: List[str] = Field(..., max_length=500)


class Sort41(Enum):
    popular = 'popular'
    newest = 'newest'
    relevance = 'relevance'
    random = 'random'
    oldest = 'oldest'


class Tag(RootModel[List[str]]):
    root: List[str]


class Id8(RootModel[List[str]]):
    root: List[str] = Field(..., max_length=500, min_length=1)


class Embed8(RootModel[List[EmbedEnum]]):
    root: List[EmbedEnum]


class Embed9(Enum):
    share_url = 'share_url'


class Embed13(RootModel[List[EmbedEnum]]):
    root: List[EmbedEnum]


class Sort43(Enum):
    newest = 'newest'
    oldest = 'oldest'


class Size9(Enum):
    web = 'web'
    sd = 'sd'
    hd = 'hd'
    field_4k = '4k'


class AspectRatio(Enum):
    field_4_3 = '4_3'
    field_16_9 = '16_9'
    nonstandard = 'nonstandard'


class LicenseEnum9(Enum):
    commercial = 'commercial'
    editorial = 'editorial'


class PeopleEthnicityEnum5(Enum):
    african = 'african'
    african_american = 'african_american'
    black = 'black'
    brazilian = 'brazilian'
    chinese = 'chinese'
    caucasian = 'caucasian'
    east_asian = 'east_asian'
    hispanic = 'hispanic'
    japanese = 'japanese'
    middle_eastern = 'middle_eastern'
    native_american = 'native_american'
    pacific_islander = 'pacific_islander'
    south_asian = 'south_asian'
    southeast_asian = 'southeast_asian'
    other = 'other'


class Resolution2(Enum):
    field_4k = '4k'
    standard_definition = 'standard_definition'
    high_definition = 'high_definition'


class Sort47(Enum):
    newest = 'newest'
    popular = 'popular'
    relevance = 'relevance'
    random = 'random'


class ContributorCountry2(RootModel[List[str]]):
    root: List[str]


class License8(RootModel[List[LicenseEnum9]]):
    root: List[LicenseEnum9]


class PeopleEthnicity2(RootModel[List[PeopleEthnicityEnum5]]):
    root: List[PeopleEthnicityEnum5]


class Sort49(Enum):
    newest = 'newest'
    oldest = 'oldest'


class AudioAssets(BaseModel):
    album_art: Optional[AudioAssetDetails] = None
    clean_audio: Optional[AudioAssetDetails] = None
    original_audio: Optional[AudioAssetDetails] = None
    preview_mp3: Optional[AudioAssetDetails] = None
    preview_ogg: Optional[AudioAssetDetails] = None
    shorts_loops_stems: Optional[ShortsLoopsStems] = None
    waveform: Optional[AudioAssetDetails] = None


class AudioRenderTimelineSpanInstrumentGroup(BaseModel):
    instrument_group: str = Field(..., description='The instrument ID')
    statuses: Optional[List[AudioRenderTimelineSpanInstrumentGroupStatus]] = Field(
        None, description='An array of status objects'
    )


class BulkImageSearchRequest(RootModel[List[SearchImage]]):
    root: List[SearchImage] = Field(
        ...,
        description='List of searches',
        examples=[
            [
                {'license': ['editorial'], 'query': 'cat', 'sort': 'popular'},
                {'orientation': 'horizontal', 'query': 'dog'},
            ]
        ],
        max_length=5,
    )


class CatalogCollection(BaseModel):
    cover_asset: Optional[CatalogCollectionItem] = None
    created_time: datetime
    id: str
    name: str
    role_assignments: CatalogCollectionRoleAssignments
    total_item_count: float
    updated_time: datetime
    visibility: Visibility


class CatalogCollectionDataList(BaseModel):
    data: List[CatalogCollection] = Field(
        ..., description='List of catalog collections'
    )
    page: float
    per_page: float
    total_count: float


class CategoryDataList(BaseModel):
    data: Optional[List[Category]] = Field(None, description='Categories')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='The current page of results')
    per_page: Optional[int] = Field(None, description='The number of results per page')
    total_count: Optional[int] = Field(
        None, description='The total number of results across all pages'
    )


class Collection(BaseModel):
    cover_item: Optional[CollectionItem] = None
    created_time: Optional[datetime] = Field(
        None, description='When the collection was created'
    )
    id: str = Field(..., description='The collection ID')
    items_updated_time: Optional[datetime] = Field(
        None, description="The last time this collection's items were updated"
    )
    name: str = Field(..., description='The name of the collection')
    share_code: Optional[str] = Field(
        None, description='A code that can be used to share the collection (optional)'
    )
    share_url: Optional[str] = Field(
        None,
        description='The browser URL that can be used to share the collection (optional)',
    )
    total_item_count: int = Field(
        ..., description='The number of items in the collection'
    )
    updated_time: Optional[datetime] = Field(
        None,
        description='The last time the collection was update (other than changes to the items in it)',
    )


class CollectionDataList(BaseModel):
    data: Optional[List[Collection]] = Field(None, description='Collections')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='The current page of results')
    per_page: Optional[int] = Field(None, description='The number of results per page')
    total_count: Optional[int] = Field(
        None, description='The total number of results across all pages'
    )


class CollectionItemDataList(BaseModel):
    data: Optional[List[CollectionItem]] = Field(
        None, description='Assets in the collection'
    )
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='The current page of results')
    per_page: Optional[int] = Field(None, description='The number of results per page')
    total_count: Optional[int] = Field(
        None, description='The total number of results across all pages'
    )


class ContributorProfile(BaseModel):
    about: Optional[str] = Field(
        None, description="Short description of the contributors' library"
    )
    contributor_type: Optional[List[str]] = Field(
        None,
        description='Type of content that the contributor specializes in (photographer, illustrator, etc)',
    )
    display_name: Optional[str] = Field(
        None, description='Preferred name to be displayed for the contributor'
    )
    equipment: Optional[List[str]] = Field(
        None,
        description='List of equipment used by the contributor (Canon EOS 5D Mark II, etc)',
    )
    id: str = Field(..., description='Contributor ID')
    location: Optional[str] = Field(
        None, description="Country code representing the contributor's locale"
    )
    portfolio_url: Optional[str] = Field(
        None, description="Web URL for the contributors' profile"
    )
    social_media: Optional[ContributorProfileSocialMedia] = None
    styles: Optional[List[str]] = Field(
        None,
        description='List of styles that the contributor specializes in (lifestyle, mixed media, etc)',
    )
    subjects: Optional[List[str]] = Field(
        None,
        description="Generic list of subjects for contributors' work (food_and_drink, holiday, people, etc)",
    )
    website: Optional[str] = Field(
        None, description='Personal website for the contributor'
    )


class ContributorProfileDataList(BaseModel):
    data: Optional[List[ContributorProfile]] = Field(
        None, description='Conributor profiles'
    )
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Error message')
    page: Optional[int] = Field(None, description='Page of response')
    per_page: Optional[int] = Field(None, description='Number of contributors per page')
    total_count: Optional[int] = Field(
        None, description='Total count of contributors for this request'
    )


class CreateCatalogCollection(BaseModel):
    items: Optional[List[CreateCatalogCollectionItem]] = Field(None, max_length=50)
    name: constr(min_length=1, max_length=100000)
    visibility: Optional[Visibility] = 'private'


class Descriptors(BaseModel):
    average_render_speed: Optional[float] = Field(
        None,
        description='The average ratio of the length of the music to the time it takes to render; for example, a render speed of 3.0 generates 30 seconds of music in about 10 seconds',
    )
    bands: Optional[List[Bands]] = Field(
        None, description='The bands that are available to use this descriptor'
    )
    id: Optional[str] = Field(None, description='The ID of the descriptor')
    instruments: Optional[List[Instruments]] = Field(
        None, description='The instruments that can play with this descriptor'
    )
    max_tempo: Optional[float] = Field(
        None,
        description='The maximum beats per minute that the descriptor is intended to be used with',
    )
    min_tempo: Optional[float] = Field(
        None,
        description='The minimum beats per minute that the descriptor is intended to be used with',
    )
    name: Optional[str] = Field(None, description='The name of the descriptor')
    previews: Optional[List[Preview]] = Field(
        None, description='Preview of the descriptor'
    )
    tags: Optional[List[str]] = Field(
        None, description='Tags that describe the descriptor'
    )


class DescriptorsListResult(BaseModel):
    data: Optional[List[Descriptors]] = Field(None, description='List of descriptors')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')


class DownloadHistory(BaseModel):
    audio: Optional[DownloadHistoryMediaDetails] = None
    download_time: datetime = Field(
        ..., description='Date the media was downloaded the first time'
    )
    id: str = Field(..., description='ID of the download')
    image: Optional[DownloadHistoryMediaDetails] = None
    is_downloadable: Optional[bool] = Field(
        None,
        description='Specifies if the media is downloadable via its respective downloads endpoint',
    )
    license: str = Field(..., description='The name of the license of this download')
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='The metadata that was passed in the original licensing request',
    )
    revshare: Optional[DownloadHistoryRevshareDetails] = None
    subscription_id: Optional[str] = Field(
        None, description='ID of the subscription used to perform this download'
    )
    user: Optional[DownloadHistoryUserDetails] = None
    video: Optional[DownloadHistoryMediaDetails] = None


class DownloadHistoryDataList(BaseModel):
    data: Optional[List[DownloadHistory]] = Field(None, description='Download events')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='The current page of results')
    per_page: Optional[int] = Field(None, description='The number of results per page')
    total_count: Optional[int] = Field(
        None, description='The total number of results across all pages'
    )


class EditorialAssets(BaseModel):
    medium_jpg: Optional[ImageSizeDetails] = None
    original: Optional[ImageSizeDetails] = None
    small_jpg: Optional[ImageSizeDetails] = None
    thumb_170: Optional[Thumbnail] = None
    thumb_220: Optional[Thumbnail] = None
    watermark_1500: Optional[Thumbnail] = None
    watermark_450: Optional[Thumbnail] = None


class EditorialContent(BaseModel):
    aspect: Optional[float] = None
    assets: Optional[EditorialAssets] = None
    byline: Optional[str] = None
    caption: Optional[str] = None
    categories: Optional[List[EditorialCategory]] = Field(
        None, description='List of categories'
    )
    date_taken: Optional[date] = None
    description: Optional[str] = None
    id: str
    keywords: Optional[List[str]] = None
    special_instructions: Optional[str] = None
    title: Optional[str] = None


class EditorialContentDataList(BaseModel):
    data: Optional[List[EditorialContent]] = Field(None, description='Editorial items')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Optional error message')
    page: Optional[int] = Field(None, description='Current page of the response')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(None, description='Total count of all results')


class EditorialImageContentDataList(BaseModel):
    data: Optional[List[EditorialContent]] = Field(None, description='Editorial items')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Optional error message')
    page: Optional[int] = Field(None, description='Current page of the response')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(None, description='Total count of all results')


class EditorialImageLivefeedList(BaseModel):
    data: List[EditorialLivefeed] = Field(..., description='Editorial livefeeds')
    message: Optional[str] = Field(None, description='Optional error message')
    page: Optional[int] = Field(None, description='Current page of the response')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: int = Field(..., description='Total count of all results')


class EditorialSearchResults(BaseModel):
    data: List[EditorialContent] = Field(..., description='Editorial items')
    message: Optional[str] = Field(None, description='Optional error message')
    next: Optional[str] = Field(
        None, description='Cursor value that represents the next page of results'
    )
    page: Optional[int] = Field(None, description='Current page of the response')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    prev: Optional[str] = Field(
        None, description='Cursor value that represents the previous page of results'
    )
    search_id: Optional[str] = Field(
        None, description='Unique identifier for the search request'
    )
    total_count: int = Field(..., description='Total count of all results')


class EditorialUpdatedContent(BaseModel):
    aspect: Optional[float] = None
    assets: Optional[EditorialAssets] = None
    byline: Optional[str] = None
    caption: Optional[str] = None
    categories: Optional[List[EditorialCategory]] = Field(
        None, description='List of categories'
    )
    commercial_status: Optional[CommercialStatus] = None
    created_time: Optional[datetime] = None
    date_taken: Optional[date] = None
    description: Optional[str] = None
    id: str
    keywords: Optional[List[str]] = None
    rights: Optional[Rights] = None
    special_instructions: Optional[str] = None
    supplier_code: Optional[str] = None
    title: Optional[str] = None
    updated_time: Optional[datetime] = None
    updates: Optional[List[str]] = None


class EditorialUpdatedResults(BaseModel):
    data: List[EditorialUpdatedContent] = Field(
        ..., description='Editorial updated items'
    )
    message: Optional[str] = Field(None, description='Optional error message')
    next: Optional[str] = Field(
        None, description='Cursor value that represents the next page of results'
    )
    per_page: Optional[int] = Field(None, description='Number of results per page')
    prev: Optional[str] = Field(
        None, description='Cursor value that represents the previous page of results'
    )


class EditorialVideoAssets(BaseModel):
    original: Optional[VideoSizeDetails] = None
    preview_mp4: Optional[VideoPreviewUrl] = None
    preview_webm: Optional[VideoPreviewUrl] = None
    thumb_jpg: Optional[VideoPreviewUrl] = None


class EditorialVideoContent(BaseModel):
    aspect: Optional[float] = None
    assets: Optional[EditorialVideoAssets] = None
    byline: Optional[str] = None
    caption: Optional[str] = None
    categories: Optional[List[EditorialCategory]] = Field(
        None, description='List of categories'
    )
    date_taken: Optional[date] = None
    description: Optional[str] = None
    id: str
    keywords: Optional[List[str]] = None
    title: Optional[str] = None


class EditorialVideoSearchResults(BaseModel):
    data: List[EditorialVideoContent] = Field(..., description='Editorial items')
    message: Optional[str] = Field(None, description='Optional error message')
    next: Optional[str] = Field(
        None, description='Cursor value that represents the next page of results'
    )
    page: Optional[int] = Field(None, description='Current page of the response')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    prev: Optional[str] = Field(
        None, description='Cursor value that represents the previous page of results'
    )
    search_id: Optional[str] = Field(
        None, description='Unique identifier for the search request'
    )
    total_count: int = Field(..., description='Total count of all results')


class FeaturedCollection(BaseModel):
    cover_item: Optional[FeaturedCollectionCoverItem] = None
    created_time: Optional[datetime] = Field(
        None, description='Date that the collection was created'
    )
    hero_item: Optional[FeaturedCollectionCoverItem] = Field(
        None,
        description='Top-level item that is meant as a cover asset, as the first asset seen to represent the collection',
    )
    id: str = Field(..., description='Collection ID')
    items_updated_time: Optional[datetime] = Field(
        None,
        description='Date that an item in the collection was last added or removed',
    )
    name: str = Field(..., description='Name of the collection')
    share_url: Optional[str] = Field(
        None, description='Unique share url for the collection'
    )
    total_item_count: int = Field(
        ..., description='Total number of items in the collection'
    )
    updated_time: Optional[datetime] = Field(
        None, description='Date that the collection was last modified'
    )


class FeaturedCollectionDataList(BaseModel):
    data: Optional[List[FeaturedCollection]] = Field(
        None, description='Featured collections'
    )
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(
        None, description='Total count of all results across all pages'
    )


class ImageAssets(BaseModel):
    huge_jpg: Optional[ImageSizeDetails] = None
    huge_thumb: Optional[Thumbnail] = None
    large_thumb: Optional[Thumbnail] = None
    medium_jpg: Optional[ImageSizeDetails] = None
    preview: Optional[Thumbnail] = None
    preview_1000: Optional[Thumbnail] = None
    preview_1500: Optional[Thumbnail] = None
    small_jpg: Optional[ImageSizeDetails] = None
    small_thumb: Optional[Thumbnail] = None
    supersize_jpg: Optional[ImageSizeDetails] = None
    vector_eps: Optional[ImageSizeDetails] = None


class Instrument(BaseModel):
    id: Optional[str] = Field(None, description='The id of the instrument')
    name: Optional[str] = Field(None, description='Name of the instrument')
    previews: Optional[List[Preview]] = Field(
        None, description='Preview of the instrument'
    )
    tags: Optional[List[str]] = Field(None, description='List of tags')


class InstrumentsListResult(BaseModel):
    data: Optional[List[Instrument]] = Field(None, description='List of instrumnets')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')


class LicenseEditorialContent(BaseModel):
    editorial_id: str = Field(..., description='Editorial ID')
    license: str = Field(..., description='License agreement to use for licensing')
    metadata: Optional[LicenseRequestMetadata] = None
    size: Optional[Size] = Field('original', description='Asset size to download')


class LicenseEditorialContentRequest(BaseModel):
    country: ISOCountryCode = Field(
        ...,
        description='Mandatory country code for where the editorial content will be distributed; this value is used for rights checks',
        examples=['USA'],
    )
    editorial: List[LicenseEditorialContent] = Field(
        ..., description='Editorial content to license'
    )


class LicenseEditorialContentResult(BaseModel):
    allotment_charge: Optional[int] = Field(
        None,
        description='For pre-paid plans, how many credits were used for the item license',
    )
    download: Optional[Url] = Field(
        None, description='Information that is needed to download the image'
    )
    editorial_id: str = Field(..., description='Editorial ID')
    error: Optional[str] = None


class LicenseEditorialContentResults(BaseModel):
    data: Optional[List[LicenseEditorialContentResult]] = Field(
        None, description='License results'
    )
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Optional error message')
    page: Optional[int] = Field(None, description='Current page of the response')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(None, description='Total count of all results')


class LicenseEditorialVideoContent(BaseModel):
    editorial_id: str = Field(..., description='Editorial ID')
    license: License1 = Field(..., description='License agreement to use for licensing')
    metadata: Optional[LicenseRequestMetadata] = None
    size: Optional[Size1] = Field('original', description='Asset size to download')


class LicenseEditorialVideoContentRequest(BaseModel):
    country: ISOCountryCode = Field(
        ...,
        description='Mandatory country code for where the editorial content will be distributed; this value is used for rights checks',
        examples=['USA'],
    )
    editorial: List[LicenseEditorialVideoContent] = Field(
        ..., description='Editorial content to license'
    )


class LicenseImage(BaseModel):
    auth_cookie: Optional[Cookie] = Field(None, description='Cookie object')
    custom_dimensions: Optional[CustomSizeDimensions] = None
    editorial_acknowledgement: Optional[bool] = Field(
        None, description='Set to true to acknowledge the editorial agreement'
    )
    format: Optional[Format] = Field(
        'jpg', description='(Deprecated) Image format to download'
    )
    image_id: str = Field(..., description='Image ID')
    metadata: Optional[LicenseRequestMetadata] = None
    price: Optional[float] = Field(
        None,
        description='For revenue-sharing transactions, the final cost to the end customer as a floating-point number in the transaction currency, such as 12.34',
    )
    search_id: Optional[str] = Field(
        None, description='ID of the search that led to this licensing transaction'
    )
    show_modal: Optional[bool] = Field(None, description='(Deprecated)')
    size: Optional[Size2] = Field(None, description='Image size to download')
    subscription_id: Optional[str] = Field(
        None, description='ID of the subscription to use for the download.'
    )
    verification_code: Optional[str] = Field(None, description='(Deprecated)')


class LicenseImageResult(BaseModel):
    allotment_charge: Optional[int] = Field(
        None, description='Number of credits that this licensing event used'
    )
    download: Optional[Url] = Field(
        None, description='Information that is needed to download the image'
    )
    error: Optional[str] = Field(
        None, description='Error message, appears only if there was an error'
    )
    image_id: str = Field(..., description='Image ID that was licensed')
    license_id: Optional[str] = Field(None, description='ID of the license event')
    price: Optional[Price] = Field(
        None, description='Wholesale price information; only for rev-share partners'
    )


class LicenseImageResultDataList(BaseModel):
    data: Optional[List[LicenseImageResult]] = Field(
        None, description='License results'
    )
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(
        None, description='Total count of all results across all pages'
    )


class LicenseImageVector(BaseModel):
    auth_cookie: Optional[Cookie] = Field(None, description='Cookie object')
    editorial_acknowledgement: Optional[bool] = Field(
        None, description='Set to true to acknowledge the editorial agreement'
    )
    format: Optional[Format1] = Field(
        'eps', description='(Deprecated) Image format to download'
    )
    image_id: str = Field(..., description='Image ID')
    metadata: Optional[LicenseRequestMetadata] = None
    price: Optional[float] = Field(
        None,
        description='For revenue-sharing transactions, the final cost to the end customer as a floating-point number in the transaction currency, such as 12.34',
    )
    search_id: Optional[str] = Field(
        None, description='ID of the search that led to this licensing transaction'
    )
    show_modal: Optional[bool] = Field(None, description='(Deprecated)')
    size: Optional[Size3] = Field(None, description='Image size to download')
    subscription_id: Optional[str] = Field(
        None, description='ID of the subscription to use for the download.'
    )
    verification_code: Optional[str] = Field(None, description='(Deprecated)')


class LicenseSFXResult(BaseModel):
    allotment_charge: Optional[int] = Field(
        None, description='Number of credits that this licensing event used'
    )
    download: Optional[Url] = Field(
        None, description='Information that is needed to download the sound effects'
    )
    error: Optional[str] = Field(
        None, description='Error message, appears only if there was an error'
    )
    license_id: Optional[str] = Field(None, description='ID of the license event')
    sfx_id: str = Field(..., description='Sound effects ID that was licensed')


class LicenseSFXResultDataList(BaseModel):
    data: Optional[List[LicenseSFXResult]] = Field(
        None, description='Sound effects license results'
    )
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')


class LicenseVideoResult(BaseModel):
    allotment_charge: Optional[int] = Field(
        None, description='Number of credits that this licensing event used'
    )
    download: Optional[Url] = None
    error: Optional[str] = Field(
        None, description='Potential error that occurred during licensing'
    )
    license_id: Optional[str] = Field(None, description='ID of the license event')
    price: Optional[Price] = Field(
        None,
        description='Wholesale price information; only for rev-share partners only',
    )
    video_id: str = Field(..., description='ID of the video that was licensed')


class LicenseVideoResultDataList(BaseModel):
    data: Optional[List[LicenseVideoResult]] = Field(
        None, description='License results'
    )
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(
        None, description='Total count of all results across all pages'
    )


class SFX(BaseModel):
    added_date: Optional[date] = Field(
        None, description='Date this sound effect was added to the Shutterstock library'
    )
    affiliate_url: Optional[str] = Field(
        None,
        description='Affiliate referral link; appears only for registered affiliate partners',
    )
    artist: Optional[str] = Field(None, description='Artist of the sound effect')
    assets: Optional[SFXAssets] = None
    contributor: Contributor
    description: Optional[str] = Field(
        None, description='Description of this sound effect'
    )
    duration: Optional[float] = Field(
        None, description='Duration of this sound effect in seconds'
    )
    id: str = Field(..., description='Shutterstock ID of this sound effect')
    keywords: Optional[List[str]] = Field(
        None, description='List of all keywords for this sound effect'
    )
    media_type: str = Field(
        ..., description='Media type of this track; should always be "sfx"'
    )
    releases: Optional[List[str]] = Field(
        None, description='List of all releases of this sound effect'
    )
    title: Optional[str] = Field(None, description='Title of this sound effect')
    updated_time: Optional[datetime] = Field(
        None, description='Time this sound effect was last updated'
    )
    url: Optional[str] = Field(None, description='')


class SFXDataList(BaseModel):
    data: Optional[List[SFX]] = Field(None, description='Sound Effects')


class SFXSearchResults(BaseModel):
    data: List[SFX] = Field(..., description='List of tracks')
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    search_id: str = Field(..., description='ID of the search')
    total_count: int = Field(
        ..., description='Total count of all results across all pages'
    )


class Subscription(BaseModel):
    allotment: Optional[Allotment] = None
    asset_type: Optional[str] = Field(
        None,
        description='Identifier for the type of assets associated with this subscription (images, videos, audio, editorial)',
    )
    description: Optional[str] = Field(
        None, description='Description of the subscription'
    )
    expiration_time: Optional[datetime] = Field(
        None, description='Date the subscription ends'
    )
    formats: Optional[List[LicenseFormat]] = Field(
        None, description='List of formats that are licensable for the subscription'
    )
    id: str = Field(..., description='Unique internal identifier for the subscription')
    license: Optional[str] = Field(
        None, description='Internal identifier for the type of subscription'
    )
    metadata: Optional[SubscriptionMetadata] = None
    price_per_download: Optional[Price] = None


class SubscriptionDataList(BaseModel):
    data: Optional[List[Subscription]] = Field(
        None, description='Subscriptions retrieved from this user'
    )
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Optional error message')
    page: Optional[int] = Field(None, description='Current page that is being queried')
    per_page: Optional[int] = Field(
        None, description='Amount of subscriptions to show per page'
    )
    total_count: Optional[int] = Field(
        None, description='Total number of subscriptions for this user'
    )


class TestValidate(BaseModel):
    header: Optional[TestValidateHeader] = Field(
        None, description='Headers as included in the request'
    )
    query: Optional[TestValidateQuery] = Field(
        None, description='Query as included in the request'
    )


class VideoAssets(BaseModel):
    field_4k: Optional[VideoSizeDetails] = Field(None, alias='4k')
    hd: Optional[VideoSizeDetails] = None
    preview_jpg: Optional[Url] = None
    preview_mp4: Optional[Url] = None
    preview_webm: Optional[Url] = None
    sd: Optional[VideoSizeDetails] = None
    thumb_jpg: Optional[Url] = None
    thumb_jpgs: Optional[Urls] = None
    thumb_mp4: Optional[Url] = None
    thumb_webm: Optional[Url] = None
    web: Optional[VideoSizeDetails] = None


class Audio(BaseModel):
    added_date: Optional[date] = Field(
        None, description='Date this track was added to the Shutterstock library'
    )
    affiliate_url: Optional[str] = Field(
        None,
        description='Affiliate referral link; appears only for registered affiliate partners',
    )
    album: Optional[Album] = None
    artists: Optional[List[Artist]] = Field(None, description='List of artists')
    assets: Optional[AudioAssets] = None
    bpm: Optional[int] = Field(None, description='BPM (beats per minute) of this track')
    contributor: Contributor
    deleted_time: Optional[datetime] = None
    description: Optional[str] = Field(None, description='Description of this track')
    duration: Optional[float] = Field(
        None, description='Duration of this track in seconds'
    )
    genres: Optional[List[str]] = Field(
        None, description='List of all genres for this track'
    )
    id: str = Field(..., description='Shutterstock ID of this track')
    instruments: Optional[List[str]] = Field(
        None, description='List of all instruments that appear in this track'
    )
    is_adult: Optional[bool] = Field(
        None, description='Whether or not this track contains adult content'
    )
    is_instrumental: Optional[bool] = Field(
        None,
        description='Whether or not this track is purely instrumental (lacking lyrics)',
    )
    isrc: Optional[str] = Field(None, description='')
    keywords: Optional[List[str]] = Field(
        None, description='List of all keywords for this track'
    )
    language: Optional[str] = Field(None, description="Language of this track's lyrics")
    lyrics: Optional[str] = Field(None, description='Lyrics of this track')
    media_type: str = Field(
        ..., description='Media type of this track; should always be "audio"'
    )
    model_releases: Optional[List[ModelRelease]] = Field(
        None, description='List of all model releases for this track'
    )
    moods: Optional[List[str]] = Field(
        None, description='List of all moods of this track'
    )
    published_time: Optional[datetime] = Field(
        None, description='Time this track was published'
    )
    recording_version: Optional[str] = Field(
        None, description='Recording version of this track'
    )
    releases: Optional[List[str]] = Field(
        None, description='List of all releases of this track'
    )
    similar_artists: Optional[List[Artist]] = Field(
        None, description='List of all similar artists of this track'
    )
    submitted_time: Optional[datetime] = Field(
        None, description='Time this track was submitted'
    )
    title: Optional[str] = Field(None, description='Title of this track')
    updated_time: Optional[datetime] = Field(
        None, description='Time this track was last updated'
    )
    url: Optional[str] = Field(None, description='')
    vocal_description: Optional[str] = Field(
        None, description='Vocal description of this track'
    )


class AudioDataList(BaseModel):
    data: Optional[List[Audio]] = Field(None, description='Tracks')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(
        None, description='Total count of all results across all pages'
    )


class AudioRenderTimelineSpan(BaseModel):
    id: Optional[float] = Field(
        None, description='An identifier which must be unique within the parent span'
    )
    instrument_groups: Optional[List[AudioRenderTimelineSpanInstrumentGroup]] = Field(
        None,
        description='An array of instrument_group objects that are used in this span',
    )
    regions: Optional[List[AudioRenderTimelineSpanRegion]] = Field(
        None, description='An array of region objects within the span'
    )
    span_type: SpanType = Field(
        ...,
        description='Type of span; metered spans represent a pariod of time with music, and unmetered spans denote the end of the prior metered span',
    )
    tempo: Optional[int] = Field(
        None,
        description='The tempo, in beats per minute, at the start of the span; if not provided, the API selects a random tempo',
    )
    tempo_changes: Optional[List[AudioRenderTimelineSpanTempoChanges]] = Field(
        None,
        description='Two or more inflection points in a tempo curve; the API creates a smoothly changing tempo by using a linear interpolation of the time between each tempo change',
    )
    time: int = Field(
        ..., description='The absolute time, in seconds, at which the span starts'
    )


class AudioSearchResults(BaseModel):
    data: List[Audio] = Field(..., description='List of tracks')
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    search_id: str = Field(..., description='ID of the search')
    total_count: int = Field(
        ..., description='Total count of all results across all pages'
    )


class Image(BaseModel):
    added_date: Optional[date] = Field(
        None, description='Date that the image was added by the contributor'
    )
    affiliate_url: Optional[AnyUrl] = Field(
        None,
        description='Affiliate referral link; appears only for registered affiliate partners',
    )
    aspect: Optional[float] = Field(
        None, description='Aspect ratio of the image in decimal format, such as 0.6667'
    )
    assets: Optional[ImageAssets] = Field(None, description='Image asset information')
    categories: Optional[List[Category]] = Field(
        None, description='Categories that this image is a part of'
    )
    contributor: Contributor
    description: Optional[str] = Field(
        None, description='Detailed description of the image'
    )
    has_model_release: Optional[bool] = Field(
        None, description='Indicates whether there are model releases for the image'
    )
    has_property_release: Optional[bool] = Field(
        None, description='Indicates whether there are property releases for the image'
    )
    id: str = Field(..., description='Image ID')
    image_type: Optional[str] = Field(None, description='Type of image')
    insights: Optional[Insights] = Field(
        None,
        description='AI-powered insights about how the asset will perform for the objective and audience',
    )
    is_adult: Optional[bool] = Field(
        None, description='Whether or not this image contains adult content'
    )
    is_editorial: Optional[bool] = Field(
        None, description='Whether or not this image is editorial content'
    )
    is_illustration: Optional[bool] = Field(
        None, description='Whether or not this image is an illustration'
    )
    keywords: Optional[List[str]] = Field(
        None, description='Keywords associated with the content of this image'
    )
    media_type: str = Field(
        ..., description='Media type of this image, should always be "image"'
    )
    model_releases: Optional[List[ModelRelease]] = Field(
        None, description='List of model releases'
    )
    models: Optional[List[Model]] = Field(None, description='List of models')
    releases: Optional[List[str]] = Field(
        None, description='List of all releases of this image'
    )
    url: Optional[str] = Field(
        None,
        description='Link to image information page; included only for certain accounts',
    )


class ImageDataList(BaseModel):
    data: Optional[List[Image]] = Field(None, description='Images')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(
        None, description='Total count of all results across all pages'
    )


class ImageSearchResults(BaseModel):
    data: List[Image] = Field(..., description='List of images')
    insights: Optional[InsightsModel] = None
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    search_id: str = Field(..., description='Unique identifier for the search request')
    spellcheck_info: Optional[Dict[str, Any]] = Field(
        None,
        description='Returns information if search phrase has potentially been mistyped or another query would lead to better search results',
    )
    total_count: int = Field(
        ..., description='Total count of all results across all pages'
    )


class LicenseImageRequest(BaseModel):
    images: List[Union[LicenseImage, LicenseImageVector]] = Field(
        ..., description='Images to create licenses for', max_length=50
    )


class Video(BaseModel):
    added_date: Optional[date] = Field(
        None, description='Date this video was added to the Shutterstock library'
    )
    affiliate_url: Optional[AnyUrl] = Field(
        None,
        description='Affiliate referral link; appears only for registered affiliate partners',
    )
    aspect: Optional[float] = Field(
        None, description='Aspect ratio of this video in decimal format, such as 0.6667'
    )
    aspect_ratio: Optional[str] = Field(
        None, description='Aspect ratio of the video as a ratio, such as 16:9'
    )
    assets: Optional[VideoAssets] = None
    categories: Optional[List[Category]] = Field(None, description='List of categories')
    contributor: Contributor
    description: Optional[str] = Field(None, description='Description of this video')
    duration: Optional[float] = Field(
        None, description='Duration of this video, in seconds'
    )
    has_model_release: Optional[bool] = Field(
        None,
        description='Whether or not this video has been released for use by the model appearing in it',
    )
    has_property_release: Optional[bool] = Field(
        None,
        description='Whether or not this video has received a release to show the landmark or property appearing in it',
    )
    id: str = Field(..., description='ID of the video')
    is_adult: Optional[bool] = Field(
        None, description='Whether or not this video contains adult content'
    )
    is_editorial: Optional[bool] = Field(
        None, description='Whether or not this video is editorial content'
    )
    keywords: Optional[List[str]] = Field(
        None, description='Keywords associated with the content of this video'
    )
    media_type: str = Field(
        ..., description='Media type of this video, should always be "video"'
    )
    models: Optional[List[Model]] = Field(
        None, description='List of models in this video'
    )
    url: Optional[str] = Field(
        None,
        description='Link to video information page; included only for certain accounts',
    )


class VideoDataList(BaseModel):
    data: Optional[List[Video]] = Field(None, description='Videos')
    errors: Optional[List[Error]] = Field(
        None, description='Error list; appears only if there was an error'
    )
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    total_count: Optional[int] = Field(
        None, description='Total count of all results across all pages'
    )


class VideoSearchResults(BaseModel):
    data: List[Video] = Field(..., description='List of videos')
    message: Optional[str] = Field(None, description='Server-generated message, if any')
    page: Optional[int] = Field(None, description='Current page that is returned')
    per_page: Optional[int] = Field(None, description='Number of results per page')
    search_id: str = Field(..., description='Unique identifier for the search request')
    total_count: int = Field(
        ..., description='Total count of all results across all pages'
    )


class AudioRenderTimeline(BaseModel):
    spans: Optional[List[AudioRenderTimelineSpan]] = Field(
        None,
        description='A span object that represents the beginning of a period of absolute time',
    )


class BulkImageSearchResults(BaseModel):
    bulk_search_id: Optional[str] = Field(
        None, description='Unique identifier for the search request'
    )
    results: Optional[List[ImageSearchResults]] = Field(
        None, description='List of image search results'
    )


class CreateAudioRender(BaseModel):
    filename: str = Field(
        ...,
        description='A user-specified file name suggestion; this file name becomes the filename property of the Content-Disposition header when the user downloads the rendered audio file',
        examples=['My Project.mp3'],
    )
    preset: Preset = Field(
        ...,
        description='File format, such as MP3 file, combined WAV file, or individual track WAV files',
        examples=['MASTER_MP3'],
    )
    timeline: AudioRenderTimeline = Field(
        ..., description='The timeline data with which to generate the render'
    )


class CreateAudioRendersRequest(BaseModel):
    audio_renders: List[CreateAudioRender] = Field(
        ..., description='Parameters to create computer audio renders'
    )


class AudioRenderResult(BaseModel):
    created_date: Optional[datetime] = Field(
        None, description='The time the render was submitted to the API'
    )
    files: Optional[List[AudioRendersFilesList]] = Field(
        None, description='The files associated with the render'
    )
    id: str = Field(..., description='The alphanumeric ID of the simple render')
    preset: Optional[Preset] = Field(None, description='The file format preset')
    progress_percent: Optional[int] = Field(
        None, description='The current progress of the render as a percentage'
    )
    status: Status = Field(..., description='A coarse progress indicator')
    timeline: AudioRenderTimeline
    updated_date: Optional[datetime] = Field(
        None, description='The time that the audio output was uploaded'
    )


class AudioRendersListResults(BaseModel):
    audio_renders: List[AudioRenderResult] = Field(
        ..., description='Audio render results'
    )
